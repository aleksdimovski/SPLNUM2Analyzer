### Starting build.
# Target: banal/ml_float.c, tags: { package(apron), package(gmp), package(oUnit), package(zarith), c, compile, extension:c, file:banal/ml_float.c, quiet }
ocamlfind ocamlc -package zarith -package oUnit -package gmp -package apron -c banal/ml_float.c # cached
# Target: banal/ml_float.o, tags: {  }
mv ml_float.o banal/ml_float.o # cached
# Target: main/Main.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:main/Main.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules main/Main.ml > main/Main.ml.depends # cached
# Target: frontend/AbstractSyntax.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:frontend/AbstractSyntax.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules frontend/AbstractSyntax.ml > frontend/AbstractSyntax.ml.depends
# Target: frontend/IntermediateSyntax.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:frontend/IntermediateSyntax.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules frontend/IntermediateSyntax.ml > frontend/IntermediateSyntax.ml.depends # cached
# Target: frontend/IntermediateSyntax.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:frontend/IntermediateSyntax.cmo, file:frontend/IntermediateSyntax.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I frontend -I domains -I main -I utils -I banal -o frontend/IntermediateSyntax.cmo frontend/IntermediateSyntax.ml # cached
# Target: main/DTAnalysisIterator.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:main/DTAnalysisIterator.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules main/DTAnalysisIterator.ml > main/DTAnalysisIterator.ml.depends # cached
# Target: frontend/AbstractSyntax.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:frontend/AbstractSyntax.cmo, file:frontend/AbstractSyntax.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I frontend -I domains -I main -I utils -I banal -o frontend/AbstractSyntax.cmo frontend/AbstractSyntax.ml
# Target: domains/DTDomain.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:domains/DTDomain.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules domains/DTDomain.ml > domains/DTDomain.ml.depends
# Target: frontend/ItoA.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:frontend/ItoA.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules frontend/ItoA.ml > frontend/ItoA.ml.depends
# Target: domains/Partition.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:domains/Partition.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules domains/Partition.ml > domains/Partition.ml.depends
# Target: utils/Constraints.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:utils/Constraints.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules utils/Constraints.ml > utils/Constraints.ml.depends
# Target: utils/Constraints.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:utils/Constraints.cmo, file:utils/Constraints.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I utils -I domains -I frontend -I main -I banal -o utils/Constraints.cmo utils/Constraints.ml
+ ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I utils -I domains -I frontend -I main -I banal -o utils/Constraints.cmo utils/Constraints.ml
File "utils/Constraints.ml", line 79, characters 4-398:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
((SUPEQ, EQ)|(EQ, SUPEQ))
# Target: frontend/ItoA.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:frontend/ItoA.cmo, file:frontend/ItoA.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I frontend -I domains -I main -I utils -I banal -o frontend/ItoA.cmo frontend/ItoA.ml
# Target: domains/Partition.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:domains/Partition.cmo, file:domains/Partition.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I domains -I frontend -I main -I utils -I banal -o domains/Partition.cmo domains/Partition.ml
# Target: utils/InvMap.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:utils/InvMap.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules utils/InvMap.ml > utils/InvMap.ml.depends
# Target: main/Iterator.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:main/Iterator.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules main/Iterator.ml > main/Iterator.ml.depends
# Target: domains/DTDomain.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:domains/DTDomain.cmo, file:domains/DTDomain.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I domains -I frontend -I main -I utils -I banal -o domains/DTDomain.cmo domains/DTDomain.ml
# Target: utils/InvMap.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:utils/InvMap.cmo, file:utils/InvMap.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I utils -I domains -I frontend -I main -I banal -o utils/InvMap.cmo utils/InvMap.ml
# Target: main/Iterator.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:main/Iterator.cmo, file:main/Iterator.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I main -I domains -I frontend -I utils -I banal -o main/Iterator.cmo main/Iterator.ml
# Target: frontend/Lexer.mll, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:mll, file:frontend/Lexer.mll, lexer, ocaml, ocamllex, quiet }
ocamllex.opt -q frontend/Lexer.mll
# Target: frontend/Lexer.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:frontend/Lexer.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules frontend/Lexer.ml > frontend/Lexer.ml.depends
# Target: frontend/Parser.mly.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:mly, file:frontend/Parser.mly, infer, menhir_ocamldep, ocaml, ocamldep, quiet }
menhir --raw-depend --ocamldep 'ocamlfind ocamldep -modules' frontend/Parser.mly > frontend/Parser.mly.depends
+ menhir --raw-depend --ocamldep 'ocamlfind ocamldep -modules' frontend/Parser.mly > frontend/Parser.mly.depends
File "frontend/Parser.mly", line 30, characters 7-20:
Warning: the token TOK_CPP_IFDEF is unused.
File "frontend/Parser.mly", line 31, characters 7-21:
Warning: the token TOK_CPP_IFNDEF is unused.
# Target: frontend/Parser.mly, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:ml, extension:mly, file:frontend/Parser.ml, file:frontend/Parser.mly, infer, menhir, ocaml, parser, quiet }
menhir --ocamlc 'ocamlfind ocamlc -package zarith -package oUnit -package gmp -package apron -I frontend -I domains -I main -I utils -I banal' --infer frontend/Parser.mly
+ menhir --ocamlc 'ocamlfind ocamlc -package zarith -package oUnit -package gmp -package apron -I frontend -I domains -I main -I utils -I banal' --infer frontend/Parser.mly
File "frontend/Parser.mly", line 30, characters 7-20:
Warning: the token TOK_CPP_IFDEF is unused.
File "frontend/Parser.mly", line 31, characters 7-21:
Warning: the token TOK_CPP_IFNDEF is unused.
Warning: one state has shift/reduce conflicts.
Warning: one shift/reduce conflict was arbitrarily resolved.
# Target: frontend/Parser.mli.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:mli, file:frontend/Parser.mli, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules frontend/Parser.mli > frontend/Parser.mli.depends
# Target: frontend/Parser.cmi, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:mli, file:frontend/Parser.mli, interf, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I frontend -I domains -I main -I utils -I banal -o frontend/Parser.cmi frontend/Parser.mli
# Target: domains/MakeDTDomain.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:domains/MakeDTDomain.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules domains/MakeDTDomain.ml > domains/MakeDTDomain.ml.depends
# Target: domains/Numerical.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:domains/Numerical.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules domains/Numerical.ml > domains/Numerical.ml.depends
# Target: banal/banal_apron_domain.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:banal/banal_apron_domain.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules banal/banal_apron_domain.ml > banal/banal_apron_domain.ml.depends
# Target: banal/banal_abstract_syntax.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:banal/banal_abstract_syntax.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules banal/banal_abstract_syntax.ml > banal/banal_abstract_syntax.ml.depends
# Target: banal/banal_datatypes.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:banal/banal_datatypes.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules banal/banal_datatypes.ml > banal/banal_datatypes.ml.depends
# Target: utils/mapext.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:utils/mapext.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules utils/mapext.ml > utils/mapext.ml.depends
# Target: utils/mapext.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:utils/mapext.cmo, file:utils/mapext.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I utils -I domains -I frontend -I main -I banal -o utils/mapext.cmo utils/mapext.ml
# Target: banal/banal_datatypes.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:banal/banal_datatypes.cmo, file:banal/banal_datatypes.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_datatypes.cmo banal/banal_datatypes.ml
# Target: banal/banal_domain.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:banal/banal_domain.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules banal/banal_domain.ml > banal/banal_domain.ml.depends
# Target: banal/banal_abstract_syntax.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:banal/banal_abstract_syntax.cmo, file:banal/banal_abstract_syntax.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_abstract_syntax.cmo banal/banal_abstract_syntax.ml
# Target: banal/banal_typed_syntax.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:banal/banal_typed_syntax.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules banal/banal_typed_syntax.ml > banal/banal_typed_syntax.ml.depends
# Target: banal/banal_float.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:banal/banal_float.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules banal/banal_float.ml > banal/banal_float.ml.depends
# Target: banal/banal_int.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:banal/banal_int.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules banal/banal_int.ml > banal/banal_int.ml.depends
# Target: banal/banal_int.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:banal/banal_int.cmo, file:banal/banal_int.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_int.cmo banal/banal_int.ml
# Target: banal/banal_intinf.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:banal/banal_intinf.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules banal/banal_intinf.ml > banal/banal_intinf.ml.depends
# Target: banal/banal_float.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:banal/banal_float.cmo, file:banal/banal_float.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_float.cmo banal/banal_float.ml
+ ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_float.cmo banal/banal_float.ml
File "banal/banal_float.ml", line 185, characters 2-78:
Warning 3: deprecated: [@@unboxed] + [@@noalloc] should be used instead of "float"
File "banal/banal_float.ml", line 186, characters 2-79:
Warning 3: deprecated: [@@unboxed] + [@@noalloc] should be used instead of "float"
File "banal/banal_float.ml", line 188, characters 2-81:
Warning 3: deprecated: [@@unboxed] + [@@noalloc] should be used instead of "float"
File "banal/banal_float.ml", line 189, characters 2-81:
Warning 3: deprecated: [@@unboxed] + [@@noalloc] should be used instead of "float"
File "banal/banal_float.ml", line 190, characters 2-81:
Warning 3: deprecated: [@@unboxed] + [@@noalloc] should be used instead of "float"
File "banal/banal_float.ml", line 191, characters 2-81:
Warning 3: deprecated: [@@unboxed] + [@@noalloc] should be used instead of "float"
# Target: banal/banal_intinf.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:banal/banal_intinf.cmo, file:banal/banal_intinf.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_intinf.cmo banal/banal_intinf.ml
# Target: banal/banal_typed_syntax.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:banal/banal_typed_syntax.cmo, file:banal/banal_typed_syntax.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_typed_syntax.cmo banal/banal_typed_syntax.ml
# Target: banal/banal_itv_rat.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:banal/banal_itv_rat.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules banal/banal_itv_rat.ml > banal/banal_itv_rat.ml.depends
# Target: banal/banal_rat.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:banal/banal_rat.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules banal/banal_rat.ml > banal/banal_rat.ml.depends
# Target: banal/banal_rat.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:banal/banal_rat.cmo, file:banal/banal_rat.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_rat.cmo banal/banal_rat.ml
# Target: banal/banal_linearization.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:banal/banal_linearization.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules banal/banal_linearization.ml > banal/banal_linearization.ml.depends
# Target: banal/banal_affine.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:banal/banal_affine.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules banal/banal_affine.ml > banal/banal_affine.ml.depends
# Target: banal/banal_itv_float.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:banal/banal_itv_float.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules banal/banal_itv_float.ml > banal/banal_itv_float.ml.depends
# Target: banal/banal_itv_int.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:banal/banal_itv_int.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules banal/banal_itv_int.ml > banal/banal_itv_int.ml.depends
# Target: banal/banal_itv_rat.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:banal/banal_itv_rat.cmo, file:banal/banal_itv_rat.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_itv_rat.cmo banal/banal_itv_rat.ml
# Target: banal/banal_mathtypes.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:banal/banal_mathtypes.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules banal/banal_mathtypes.ml > banal/banal_mathtypes.ml.depends
# Target: banal/banal_itv_float.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:banal/banal_itv_float.cmo, file:banal/banal_itv_float.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_itv_float.cmo banal/banal_itv_float.ml
# Target: banal/banal_itv_int.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:banal/banal_itv_int.cmo, file:banal/banal_itv_int.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_itv_int.cmo banal/banal_itv_int.ml
# Target: banal/banal_mathtypes.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:banal/banal_mathtypes.cmo, file:banal/banal_mathtypes.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_mathtypes.cmo banal/banal_mathtypes.ml
# Target: banal/banal_domain.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:banal/banal_domain.cmo, file:banal/banal_domain.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_domain.cmo banal/banal_domain.ml
# Target: banal/banal_semantics.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:banal/banal_semantics.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules banal/banal_semantics.ml > banal/banal_semantics.ml.depends
# Target: banal/banal_affine.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:banal/banal_affine.cmo, file:banal/banal_affine.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_affine.cmo banal/banal_affine.ml
# Target: banal/banal_semantics.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:banal/banal_semantics.cmo, file:banal/banal_semantics.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_semantics.cmo banal/banal_semantics.ml
# Target: banal/banal_linearization.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:banal/banal_linearization.cmo, file:banal/banal_linearization.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_linearization.cmo banal/banal_linearization.ml
# Target: banal/function_banal_converter.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:banal/function_banal_converter.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules banal/function_banal_converter.ml > banal/function_banal_converter.ml.depends
# Target: banal/banal_apron_domain.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:banal/banal_apron_domain.cmo, file:banal/banal_apron_domain.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_apron_domain.cmo banal/banal_apron_domain.ml
# Target: banal/function_banal_converter.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:banal/function_banal_converter.cmo, file:banal/function_banal_converter.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/function_banal_converter.cmo banal/function_banal_converter.ml
+ ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/function_banal_converter.cmo banal/function_banal_converter.ml
File "banal/function_banal_converter.ml", line 45, characters 16-160:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
A_MOD
File "banal/function_banal_converter.ml", line 29, characters 2-952:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
A_URANDOM
File "banal/function_banal_converter.ml", line 56, characters 2-947:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
A_bvar _
# Target: domains/Numerical.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:domains/Numerical.cmo, file:domains/Numerical.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I domains -I frontend -I main -I utils -I banal -o domains/Numerical.cmo domains/Numerical.ml
+ ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I domains -I frontend -I main -I utils -I banal -o domains/Numerical.cmo domains/Numerical.ml
File "domains/Numerical.ml", line 261, characters 4-2919:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
A_bvar _
# Target: domains/Maketuple.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:domains/Maketuple.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules domains/Maketuple.ml > domains/Maketuple.ml.depends
# Target: domains/Tuple.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:domains/Tuple.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules domains/Tuple.ml > domains/Tuple.ml.depends
# Target: domains/Tuple.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:domains/Tuple.cmo, file:domains/Tuple.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I domains -I frontend -I main -I utils -I banal -o domains/Tuple.cmo domains/Tuple.ml
# Target: main/SingleAnalysisIterator.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:main/SingleAnalysisIterator.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules main/SingleAnalysisIterator.ml > main/SingleAnalysisIterator.ml.depends
# Target: main/TupleAnalysisIterator.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:main/TupleAnalysisIterator.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules main/TupleAnalysisIterator.ml > main/TupleAnalysisIterator.ml.depends
# Target: main/DTAnalysisIterator.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:main/DTAnalysisIterator.cmo, file:main/DTAnalysisIterator.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I main -I domains -I frontend -I utils -I banal -o main/DTAnalysisIterator.cmo main/DTAnalysisIterator.ml
+ ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I main -I domains -I frontend -I utils -I banal -o main/DTAnalysisIterator.cmo main/DTAnalysisIterator.ml
File "main/DTAnalysisIterator.ml", line 98, characters 3-4:
Warning 11: this match case is unused.
File "main/DTAnalysisIterator.ml", line 180, characters 8-13:
Warning 26: unused variable state.
# Target: frontend/Lexer.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:frontend/Lexer.cmo, file:frontend/Lexer.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I frontend -I domains -I main -I utils -I banal -o frontend/Lexer.cmo frontend/Lexer.ml
# Target: domains/MakeDTDomain.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:domains/MakeDTDomain.cmo, file:domains/MakeDTDomain.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I domains -I frontend -I main -I utils -I banal -o domains/MakeDTDomain.cmo domains/MakeDTDomain.ml
+ ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I domains -I frontend -I main -I utils -I banal -o domains/MakeDTDomain.cmo domains/MakeDTDomain.ml
File "domains/MakeDTDomain.ml", line 92, characters 5-10:
Warning 26: unused variable feats.
File "domains/MakeDTDomain.ml", line 648, characters 8-9:
Warning 11: this match case is unused.
File "domains/MakeDTDomain.ml", line 677, characters 8-9:
Warning 11: this match case is unused.
File "domains/MakeDTDomain.ml", line 707, characters 8-9:
Warning 11: this match case is unused.
File "domains/MakeDTDomain.ml", line 867, characters 8-16:
Warning 26: unused variable env_vars.
File "domains/MakeDTDomain.ml", line 869, characters 8-12:
Warning 26: unused variable vars.
File "domains/MakeDTDomain.ml", line 871, characters 8-20:
Warning 26: unused variable print_domain.
File "domains/MakeDTDomain.ml", line 889, characters 8-16:
Warning 26: unused variable env_vars.
File "domains/MakeDTDomain.ml", line 891, characters 8-12:
Warning 26: unused variable vars.
# Target: domains/Maketuple.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:domains/Maketuple.cmo, file:domains/Maketuple.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I domains -I frontend -I main -I utils -I banal -o domains/Maketuple.cmo domains/Maketuple.ml
+ ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I domains -I frontend -I main -I utils -I banal -o domains/Maketuple.cmo domains/Maketuple.ml
File "domains/Maketuple.ml", line 205, characters 82-88:
Warning 40: featId was selected from type ItoA.feat.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "domains/Maketuple.ml", line 223, characters 82-88:
Warning 40: featId was selected from type ItoA.feat.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "domains/Maketuple.ml", line 241, characters 82-88:
Warning 40: featId was selected from type ItoA.feat.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "domains/Maketuple.ml", line 259, characters 82-88:
Warning 40: featId was selected from type ItoA.feat.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
# Target: main/SingleAnalysisIterator.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:main/SingleAnalysisIterator.cmo, file:main/SingleAnalysisIterator.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I main -I domains -I frontend -I utils -I banal -o main/SingleAnalysisIterator.cmo main/SingleAnalysisIterator.ml
+ ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I main -I domains -I frontend -I utils -I banal -o main/SingleAnalysisIterator.cmo main/SingleAnalysisIterator.ml
File "main/SingleAnalysisIterator.ml", line 114, characters 8-13:
Warning 26: unused variable state.
# Target: main/TupleAnalysisIterator.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:main/TupleAnalysisIterator.cmo, file:main/TupleAnalysisIterator.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I main -I domains -I frontend -I utils -I banal -o main/TupleAnalysisIterator.cmo main/TupleAnalysisIterator.ml
+ ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I main -I domains -I frontend -I utils -I banal -o main/TupleAnalysisIterator.cmo main/TupleAnalysisIterator.ml
File "main/TupleAnalysisIterator.ml", line 152, characters 8-13:
Warning 26: unused variable state.
# Target: main/Main.cmo, tags: { package(apron), package(gmp), package(oUnit), package(zarith), byte, compile, extension:cmo, extension:ml, file:main/Main.cmo, file:main/Main.ml, implem, ocaml, quiet }
ocamlfind ocamlc -c -package zarith -package oUnit -package gmp -package apron -I main -I domains -I frontend -I utils -I banal -o main/Main.cmo main/Main.ml
# Target: frontend/IntermediateSyntax.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:frontend/IntermediateSyntax.cmx, file:frontend/IntermediateSyntax.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I frontend -I domains -I main -I utils -I banal -o frontend/IntermediateSyntax.cmx frontend/IntermediateSyntax.ml
# Target: frontend/AbstractSyntax.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:frontend/AbstractSyntax.cmx, file:frontend/AbstractSyntax.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I frontend -I domains -I main -I utils -I banal -o frontend/AbstractSyntax.cmx frontend/AbstractSyntax.ml
# Target: utils/Constraints.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:utils/Constraints.cmx, file:utils/Constraints.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I utils -I domains -I frontend -I main -I banal -o utils/Constraints.cmx utils/Constraints.ml
+ ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I utils -I domains -I frontend -I main -I banal -o utils/Constraints.cmx utils/Constraints.ml
File "utils/Constraints.ml", line 79, characters 4-398:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
((SUPEQ, EQ)|(EQ, SUPEQ))
# Target: frontend/ItoA.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:frontend/ItoA.cmx, file:frontend/ItoA.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I frontend -I domains -I main -I utils -I banal -o frontend/ItoA.cmx frontend/ItoA.ml
# Target: domains/Partition.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:domains/Partition.cmx, file:domains/Partition.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I domains -I frontend -I main -I utils -I banal -o domains/Partition.cmx domains/Partition.ml
# Target: domains/DTDomain.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:domains/DTDomain.cmx, file:domains/DTDomain.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I domains -I frontend -I main -I utils -I banal -o domains/DTDomain.cmx domains/DTDomain.ml
# Target: utils/InvMap.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:utils/InvMap.cmx, file:utils/InvMap.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I utils -I domains -I frontend -I main -I banal -o utils/InvMap.cmx utils/InvMap.ml
# Target: main/Iterator.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:main/Iterator.cmx, file:main/Iterator.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I main -I domains -I frontend -I utils -I banal -o main/Iterator.cmx main/Iterator.ml
# Target: frontend/Parser.ml.depends, tags: { package(apron), package(gmp), package(oUnit), package(zarith), extension:ml, file:frontend/Parser.ml, ocaml, ocamldep, quiet }
ocamlfind ocamldep -package zarith -package oUnit -package gmp -package apron -modules frontend/Parser.ml > frontend/Parser.ml.depends
# Target: frontend/Parser.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:frontend/Parser.cmx, file:frontend/Parser.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I frontend -I domains -I main -I utils -I banal -o frontend/Parser.cmx frontend/Parser.ml
+ ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I frontend -I domains -I main -I utils -I banal -o frontend/Parser.cmx frontend/Parser.ml
File "frontend/Parser.ml", line 2392, characters 21-22:
Warning 26: unused variable b.
File "frontend/Parser.ml", line 2403, characters 38-39:
Warning 26: unused variable p.
File "frontend/Parser.ml", line 2433, characters 21-22:
Warning 26: unused variable d.
# Target: utils/mapext.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:utils/mapext.cmx, file:utils/mapext.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I utils -I domains -I frontend -I main -I banal -o utils/mapext.cmx utils/mapext.ml
# Target: banal/banal_datatypes.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:banal/banal_datatypes.cmx, file:banal/banal_datatypes.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_datatypes.cmx banal/banal_datatypes.ml
# Target: banal/banal_abstract_syntax.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:banal/banal_abstract_syntax.cmx, file:banal/banal_abstract_syntax.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_abstract_syntax.cmx banal/banal_abstract_syntax.ml
# Target: banal/banal_int.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:banal/banal_int.cmx, file:banal/banal_int.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_int.cmx banal/banal_int.ml
# Target: banal/banal_float.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:banal/banal_float.cmx, file:banal/banal_float.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_float.cmx banal/banal_float.ml
+ ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_float.cmx banal/banal_float.ml
File "banal/banal_float.ml", line 185, characters 2-78:
Warning 3: deprecated: [@@unboxed] + [@@noalloc] should be used instead of "float"
File "banal/banal_float.ml", line 186, characters 2-79:
Warning 3: deprecated: [@@unboxed] + [@@noalloc] should be used instead of "float"
File "banal/banal_float.ml", line 188, characters 2-81:
Warning 3: deprecated: [@@unboxed] + [@@noalloc] should be used instead of "float"
File "banal/banal_float.ml", line 189, characters 2-81:
Warning 3: deprecated: [@@unboxed] + [@@noalloc] should be used instead of "float"
File "banal/banal_float.ml", line 190, characters 2-81:
Warning 3: deprecated: [@@unboxed] + [@@noalloc] should be used instead of "float"
File "banal/banal_float.ml", line 191, characters 2-81:
Warning 3: deprecated: [@@unboxed] + [@@noalloc] should be used instead of "float"
# Target: banal/banal_intinf.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:banal/banal_intinf.cmx, file:banal/banal_intinf.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_intinf.cmx banal/banal_intinf.ml
# Target: banal/banal_typed_syntax.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:banal/banal_typed_syntax.cmx, file:banal/banal_typed_syntax.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_typed_syntax.cmx banal/banal_typed_syntax.ml
# Target: banal/banal_rat.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:banal/banal_rat.cmx, file:banal/banal_rat.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_rat.cmx banal/banal_rat.ml
# Target: banal/banal_itv_rat.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:banal/banal_itv_rat.cmx, file:banal/banal_itv_rat.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_itv_rat.cmx banal/banal_itv_rat.ml
# Target: banal/banal_itv_float.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:banal/banal_itv_float.cmx, file:banal/banal_itv_float.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_itv_float.cmx banal/banal_itv_float.ml
# Target: banal/banal_itv_int.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:banal/banal_itv_int.cmx, file:banal/banal_itv_int.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_itv_int.cmx banal/banal_itv_int.ml
# Target: banal/banal_mathtypes.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:banal/banal_mathtypes.cmx, file:banal/banal_mathtypes.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_mathtypes.cmx banal/banal_mathtypes.ml
# Target: banal/banal_domain.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:banal/banal_domain.cmx, file:banal/banal_domain.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_domain.cmx banal/banal_domain.ml
# Target: banal/banal_affine.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:banal/banal_affine.cmx, file:banal/banal_affine.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_affine.cmx banal/banal_affine.ml
# Target: banal/banal_semantics.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:banal/banal_semantics.cmx, file:banal/banal_semantics.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_semantics.cmx banal/banal_semantics.ml
# Target: banal/banal_linearization.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:banal/banal_linearization.cmx, file:banal/banal_linearization.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_linearization.cmx banal/banal_linearization.ml
# Target: banal/banal_apron_domain.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:banal/banal_apron_domain.cmx, file:banal/banal_apron_domain.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/banal_apron_domain.cmx banal/banal_apron_domain.ml
# Target: banal/function_banal_converter.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:banal/function_banal_converter.cmx, file:banal/function_banal_converter.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/function_banal_converter.cmx banal/function_banal_converter.ml
+ ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I banal -I domains -I frontend -I main -I utils -o banal/function_banal_converter.cmx banal/function_banal_converter.ml
File "banal/function_banal_converter.ml", line 45, characters 16-160:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
A_MOD
File "banal/function_banal_converter.ml", line 29, characters 2-952:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
A_URANDOM
File "banal/function_banal_converter.ml", line 56, characters 2-947:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
A_bvar _
# Target: domains/Numerical.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:domains/Numerical.cmx, file:domains/Numerical.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I domains -I frontend -I main -I utils -I banal -o domains/Numerical.cmx domains/Numerical.ml
+ ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I domains -I frontend -I main -I utils -I banal -o domains/Numerical.cmx domains/Numerical.ml
File "domains/Numerical.ml", line 261, characters 4-2919:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
A_bvar _
# Target: domains/Tuple.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:domains/Tuple.cmx, file:domains/Tuple.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I domains -I frontend -I main -I utils -I banal -o domains/Tuple.cmx domains/Tuple.ml
# Target: main/DTAnalysisIterator.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:main/DTAnalysisIterator.cmx, file:main/DTAnalysisIterator.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I main -I domains -I frontend -I utils -I banal -o main/DTAnalysisIterator.cmx main/DTAnalysisIterator.ml
+ ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I main -I domains -I frontend -I utils -I banal -o main/DTAnalysisIterator.cmx main/DTAnalysisIterator.ml
File "main/DTAnalysisIterator.ml", line 98, characters 3-4:
Warning 11: this match case is unused.
File "main/DTAnalysisIterator.ml", line 180, characters 8-13:
Warning 26: unused variable state.
# Target: frontend/Lexer.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:frontend/Lexer.cmx, file:frontend/Lexer.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I frontend -I domains -I main -I utils -I banal -o frontend/Lexer.cmx frontend/Lexer.ml
# Target: domains/MakeDTDomain.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:domains/MakeDTDomain.cmx, file:domains/MakeDTDomain.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I domains -I frontend -I main -I utils -I banal -o domains/MakeDTDomain.cmx domains/MakeDTDomain.ml
+ ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I domains -I frontend -I main -I utils -I banal -o domains/MakeDTDomain.cmx domains/MakeDTDomain.ml
File "domains/MakeDTDomain.ml", line 92, characters 5-10:
Warning 26: unused variable feats.
File "domains/MakeDTDomain.ml", line 648, characters 8-9:
Warning 11: this match case is unused.
File "domains/MakeDTDomain.ml", line 677, characters 8-9:
Warning 11: this match case is unused.
File "domains/MakeDTDomain.ml", line 707, characters 8-9:
Warning 11: this match case is unused.
File "domains/MakeDTDomain.ml", line 867, characters 8-16:
Warning 26: unused variable env_vars.
File "domains/MakeDTDomain.ml", line 869, characters 8-12:
Warning 26: unused variable vars.
File "domains/MakeDTDomain.ml", line 871, characters 8-20:
Warning 26: unused variable print_domain.
File "domains/MakeDTDomain.ml", line 889, characters 8-16:
Warning 26: unused variable env_vars.
File "domains/MakeDTDomain.ml", line 891, characters 8-12:
Warning 26: unused variable vars.
# Target: domains/Maketuple.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:domains/Maketuple.cmx, file:domains/Maketuple.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I domains -I frontend -I main -I utils -I banal -o domains/Maketuple.cmx domains/Maketuple.ml
+ ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I domains -I frontend -I main -I utils -I banal -o domains/Maketuple.cmx domains/Maketuple.ml
File "domains/Maketuple.ml", line 205, characters 82-88:
Warning 40: featId was selected from type ItoA.feat.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "domains/Maketuple.ml", line 223, characters 82-88:
Warning 40: featId was selected from type ItoA.feat.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "domains/Maketuple.ml", line 241, characters 82-88:
Warning 40: featId was selected from type ItoA.feat.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "domains/Maketuple.ml", line 259, characters 82-88:
Warning 40: featId was selected from type ItoA.feat.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
# Target: main/SingleAnalysisIterator.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:main/SingleAnalysisIterator.cmx, file:main/SingleAnalysisIterator.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I main -I domains -I frontend -I utils -I banal -o main/SingleAnalysisIterator.cmx main/SingleAnalysisIterator.ml
+ ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I main -I domains -I frontend -I utils -I banal -o main/SingleAnalysisIterator.cmx main/SingleAnalysisIterator.ml
File "main/SingleAnalysisIterator.ml", line 114, characters 8-13:
Warning 26: unused variable state.
# Target: main/TupleAnalysisIterator.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:main/TupleAnalysisIterator.cmx, file:main/TupleAnalysisIterator.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I main -I domains -I frontend -I utils -I banal -o main/TupleAnalysisIterator.cmx main/TupleAnalysisIterator.ml
+ ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I main -I domains -I frontend -I utils -I banal -o main/TupleAnalysisIterator.cmx main/TupleAnalysisIterator.ml
File "main/TupleAnalysisIterator.ml", line 152, characters 8-13:
Warning 26: unused variable state.
# Target: main/Main.cmx, tags: { package(apron), package(gmp), package(oUnit), package(zarith), compile, extension:cmx, extension:ml, file:main/Main.cmx, file:main/Main.ml, implem, native, ocaml, quiet }
ocamlfind ocamlopt -c -package zarith -package oUnit -package gmp -package apron -I main -I domains -I frontend -I utils -I banal -o main/Main.cmx main/Main.ml
# Target: main/Main.native, tags: { package(apron), package(gmp), package(oUnit), package(zarith), dont_link_with, extension:native, file:main/Main.native, link, native, ocaml, program, quiet }
ocamlfind ocamlopt banal/ml_float.o boxMPQ.cmxa octD.cmxa polkaMPQ.cmxa str.cmxa zarith.cmxa -linkpkg -package zarith -package oUnit -package gmp -package apron -I utils -I banal -I frontend -I domains -I main utils/mapext.cmx banal/banal_datatypes.cmx banal/banal_abstract_syntax.cmx banal/banal_int.cmx banal/banal_float.cmx banal/banal_intinf.cmx banal/banal_itv_float.cmx banal/banal_itv_int.cmx banal/banal_rat.cmx banal/banal_itv_rat.cmx banal/banal_mathtypes.cmx banal/banal_affine.cmx banal/banal_typed_syntax.cmx banal/banal_domain.cmx banal/banal_semantics.cmx banal/banal_linearization.cmx banal/banal_apron_domain.cmx frontend/IntermediateSyntax.cmx frontend/AbstractSyntax.cmx banal/function_banal_converter.cmx utils/Constraints.cmx domains/Partition.cmx frontend/ItoA.cmx domains/DTDomain.cmx domains/Numerical.cmx domains/MakeDTDomain.cmx domains/Tuple.cmx domains/Maketuple.cmx frontend/Parser.cmx frontend/Lexer.cmx main/Iterator.cmx utils/InvMap.cmx main/DTAnalysisIterator.cmx main/SingleAnalysisIterator.cmx main/TupleAnalysisIterator.cmx main/Main.cmx -o main/Main.native
# Compilation successful.
